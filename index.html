<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Tetris Ultimate - Controller Menu Support</title>
    <style>
        body { 
            background: #0a0a0a; 
            background-position: center;
            background-size: cover;
            background-repeat: no-repeat;
            color: #fff; 
            font-family: 'Segoe UI', sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            height: 100vh; 
            margin: 0; 
            overflow: hidden; 
            user-select: none; 
            transition: background-image 0.5s ease;
        }

        #game-layout { 
            display: flex; 
            gap: 20px; 
            align-items: flex-start; 
            background: rgba(0, 0, 0, 0.6); 
            padding: 20px; 
            border-radius: 15px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #game-container { position: relative; border: 4px solid #333; border-radius: 5px; box-shadow: 0 0 40px rgba(0, 210, 255, 0.2); }
        canvas#tetris { display: block; background-color: rgba(0, 0, 0, 0.3); cursor: crosshair; }
        
        .side-panel { display: flex; flex-direction: column; gap: 10px; width: 120px; }
        .stats-panel { width: 150px; } 
        .panel-box { background: rgba(26, 26, 26, 0.8); border: 2px solid #444; border-radius: 5px; padding: 10px; text-align: center; }
        .panel-title { font-size: 11px; color: #00d2ff; margin-bottom: 5px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
        
        #ren-container { height: 65px; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: transform 0.1s ease; }
        #ren-count { font-size: 40px; font-weight: bold; color: #ff9900; margin: 0; line-height: 1; text-shadow: 0 0 15px rgba(255, 153, 0, 0.5); }
        #ren-label { font-size: 12px; color: #aaa; margin: 0; font-weight: bold; }
        .bump { transform: scale(1.3); }
        
        .slot { border: 2px solid #333; background: #000; height: 60px; display: flex; justify-content: center; align-items: center; }
        .sub-slots { display: grid; grid-template-rows: repeat(4, 35px); gap: 4px; margin-top: 5px; }
        .sub-slot { height: 35px; border: 1px solid #333; background: #000; border-radius: 4px; display: flex; justify-content: center; align-items: center; }
        
        #score { font-size: 20px; font-weight: bold; color: #00ffcc; text-shadow: 0 0 10px rgba(0, 255, 204, 0.5); }
        
        .stat-row { display: flex; justify-content: space-between; font-size: 12px; margin: 2px 0; color: #ccc; border-bottom: 1px solid #333; }
        .stat-val { color: #fff; font-weight: bold; }
        .stat-high { color: #ffd700; }

        #shop-trigger, #options-trigger { background: linear-gradient(135deg, #00d2ff, #ff00ff); border: none; border-radius: 25px; color: #fff; font-weight: bold; padding: 12px 30px; margin-bottom: 20px; cursor: pointer; box-shadow: 0 4px 15px rgba(0, 210, 255, 0.4); transition: 0.2s; text-transform: uppercase; }
        #options-trigger { background: #333; padding: 12px 20px; font-size: 20px; line-height: 1; }
        #shop-trigger:hover, #options-trigger:hover { transform: scale(1.05); filter: brightness(1.2); }
        
        .nav-bar { display: flex; gap: 10px; align-items: center; }

        .overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 100; justify-content: center; align-items: center; backdrop-filter: blur(8px); }
        .menu-card { background: #111; border: 3px solid #00d2ff; padding: 30px; border-radius: 15px; width: 420px; text-align: center; box-shadow: 0 0 50px rgba(0, 210, 255, 0.3); }
        
        /* --- ãƒ¡ãƒ‹ãƒ¥ãƒ¼é¸æŠæ™‚ã®ã‚¹ã‚¿ã‚¤ãƒ« --- */
        .menu-item { background: #222; border: 2px solid #444; border-radius: 10px; padding: 12px; margin: 8px 0; cursor: pointer; font-size: 16px; font-weight: bold; transition: 0.2s; display: flex; justify-content: space-between; align-items: center; }
        .menu-item:hover, .menu-item.selected { border-color: #00d2ff; color: #00d2ff; background: #2a2a2a; box-shadow: 0 0 15px rgba(0, 210, 255, 0.4); transform: scale(1.02); }
        
        .url-input { width: 90%; padding: 8px; margin-top: 8px; background: #000; border: 1px solid #444; color: #00d2ff; border-radius: 5px; font-size: 12px; outline: none; }
        .url-input:focus { border-color: #00d2ff; }
        .close-btn { margin-top: 20px; color: #aaa; cursor: pointer; font-size: 14px; border: 1px solid transparent; padding: 5px; border-radius: 5px; }
        .close-btn.selected { border-color: #ff4444; color: #ff4444; }
        
        .switch { position: relative; display: inline-block; width: 44px; height: 22px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #444; transition: .4s; border-radius: 22px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #00d2ff; }
        input:checked + .slider:before { transform: translateX(22px); }
    </style>
</head>
<body oncontextmenu="return false;">

    <div class="nav-bar">
        <button id="shop-trigger" onclick="toggleShop()">ğŸ›’ Template Database</button>
        <button id="options-trigger" onclick="toggleOptions()">â˜°</button>
    </div>

    <div id="shop-overlay" class="overlay">
        <div class="menu-card" id="shop-card">
            <h2 style="color:#00d2ff; margin-top:0;">âœ¨ SELECT SEQUENCE âœ¨</h2>
            <div class="menu-item" style="color:#ffd700;" onclick="buyTSpinTemplate()">T-Spin Triple Tower</div>
            <div class="menu-item" style="color:#ffcc00;" onclick="buyHachimitsu()">Hachimitsu Cannon</div>
            <div class="menu-item" style="color:#00ff88;" onclick="buyOpeningTD()">Opening TD Attack</div>
            <div class="menu-item" style="color:#00d2ff;" onclick="buyRenTemplate()">4-Wide REN</div>
            <div class="close-btn" onclick="toggleShop()">[ CANCEL ]</div>
        </div>
    </div>

    <div id="options-overlay" class="overlay">
        <div class="menu-card" id="options-card">
            <h2 style="color:#ff00ff; margin-top:0;">âš™ï¸ OPTIONS</h2>
            <div class="menu-item" style="flex-direction: column; align-items: flex-start; cursor: default;">
                <div style="display:flex; justify-content: space-between; width:100%;">
                    <span>Custom Background URL</span>
                    <span style="font-size:10px; color:#666;">Apply on input</span>
                </div>
                <input type="text" id="bg-url-input" class="url-input" placeholder="https://image-url.jpg" oninput="changeBackground(this.value)">
            </div>
            <div class="menu-item" onclick="resetGame()">
                <span>RETRY GAME</span>
                <span style="font-size: 12px; color: #ff4444;">â†»</span>
            </div>
            <div class="menu-item" onclick="toggleCheckbox('shake-harddrop')">
                <span>HardDrop Shake</span>
                <label class="switch">
                    <input type="checkbox" id="shake-harddrop" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="menu-item" onclick="toggleCheckbox('shake-line')">
                <span>Line Clear Shake</span>
                <label class="switch">
                    <input type="checkbox" id="shake-line" checked>
                    <span class="slider"></span>
                </label>
            </div>
<div class="menu-item" onclick="toggleSE()">
    <span>SE SOUND</span>
    <label class="switch">
        <input type="checkbox" id="se-toggle" checked>
        <span class="slider"></span>
    </label>
</div>
<div class="menu-item">
    <span>Select BGM (MP3/WAV/OGG)</span>
    <input type="file" id="bgm-upload" accept=".mp3, .wav, .ogg, audio/mp3, audio/wav, audio/ogg" style="display:none" onchange="loadLocalBGM(this)">
    <button onclick="document.getElementById('bgm-upload').click()" style="background:#444; color:#fff; border:none; border-radius:5px; cursor:pointer;">ğŸ“ Open</button>
</div>
            <div class="close-btn" onclick="toggleOptions()">[ CLOSE & RESUME ]</div>
        </div>
    </div>

    <div id="game-layout">
        <div class="side-panel">
            <div class="panel-box"><div class="panel-title">HOLD</div><div class="slot"><canvas id="hold-canvas" width="60" height="60"></canvas></div></div>
            <div class="panel-box"><div class="panel-title">SCORE</div><div id="score">0</div></div>
            <div class="panel-box">
                <div class="panel-title">COMBO</div>
                <div id="ren-container">
                    <p id="ren-count">0</p>
                    <p id="ren-label">REN</p>
                </div>
            </div>
        </div>

        <div id="game-container"><canvas id="tetris" width="200" height="400"></canvas></div>

        <div class="side-panel stats-panel">
            <div class="panel-box">
                <div class="panel-title">NEXT</div>
                <div class="slot"><canvas id="next-1" width="60" height="60"></canvas></div>
                <div class="sub-slots">
                    <div class="sub-slot"><canvas id="next-2" width="35" height="35"></canvas></div>
                    <div class="sub-slot"><canvas id="next-3" width="35" height="35"></canvas></div>
                    <div class="sub-slot"><canvas id="next-4" width="35" height="35"></canvas></div>
                    <div class="sub-slot"><canvas id="next-5" width="35" height="35"></canvas></div>
                </div>
            </div>

            <div class="panel-box">
                <div class="panel-title">STATISTICS</div>
                <div class="stat-row"><span>HIGH SCORE</span><span id="stat-high-score" class="stat-val stat-high">0</span></div>
                <div class="stat-row"><span>MAX REN</span><span id="stat-max-ren" class="stat-val">0</span></div>
                <div class="stat-row"><span>LINES</span><span id="stat-total-lines" class="stat-val">0</span></div>
                <div class="stat-row"><span>TETRIS</span><span id="stat-tetris" class="stat-val">0</span></div>
                <div class="stat-row"><span>TS (S)</span><span id="stat-ts" class="stat-val">0</span></div>
                <div class="stat-row"><span>TD (D)</span><span id="stat-td" class="stat-val">0</span></div>
                <div class="stat-row"><span>TT (T)</span><span id="stat-tt" class="stat-val">0</span></div>
                <div class="stat-row"><span>BTB</span><span id="stat-btb" class="stat-val">0</span></div>
            </div>
        </div>
    </div>

<script>
// --- è¿½åŠ ï¼šãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç®¡ç† ---
let currentMenuIndex = 0;
let activeMenuElements = [];

function changeBackground(url) {
    if (url.trim() === "") {
        document.body.style.backgroundImage = "none";
    } else {
        document.body.style.backgroundImage = `url('${url}')`;
    }
}

const canvas = document.getElementById('tetris');
const context = canvas.getContext('2d');
const scoreElement = document.getElementById('score');
const renCountElement = document.getElementById('ren-count');
const renContainer = document.getElementById('ren-container');
const holdCanvas = document.getElementById('hold-canvas').getContext('2d');
const nextCtxs = [1,2,3,4,5].map(i => document.getElementById(i===1?'next-1':`next-${i}`).getContext('2d'));

const statElems = {
    highScore: document.getElementById('stat-high-score'),
    maxRen: document.getElementById('stat-max-ren'),
    totalLines: document.getElementById('stat-total-lines'),
    tetris: document.getElementById('stat-tetris'),
    ts: document.getElementById('stat-ts'),
    td: document.getElementById('stat-td'),
    tt: document.getElementById('stat-tt'),
    btb: document.getElementById('stat-btb')
};

context.scale(20, 20);
holdCanvas.scale(15, 15);
nextCtxs[0].scale(15, 15);
for(let i=1; i<5; i++) nextCtxs[i].scale(8, 8);

// ãƒŸãƒã®ç¨®é¡ï¼ˆPIECE_TYPESï¼‰ã®ä¸¦ã³é †ã«åˆã‚ã›ã¦è‰²ã‚’è¨­å®šã—ã¾ã—ãŸï¼
// 1:T(ç´«), 2:L(é’), 3:J(æ©™), 4:O(é»„), 5:Z(èµ¤), 6:S(ç·‘), 7:I(æ°´è‰²)
const COLORS = [
    null, 
    '#00FFFF', // T: ç´« (Purple)
    '#0055FF', // L: é’ (Blue)
    '#FF8C00', // J: ã‚ªãƒ¬ãƒ³ã‚¸ (Orange)
    '#FFD700', // O: é»„è‰² (Yellow)
    '#FF2D2D', // Z: èµ¤ (Red)
    '#00FF44', // S: ç·‘ (Green)
    '#00D2FF', // I: æ°´è‰² (Cyan)
    '#444'     // 8: å£ãªã©ï¼ˆäºˆå‚™ï¼‰
];const PIECE_TYPES = ['I', 'L', 'J', 'O', 'Z', 'S', 'T'];

const SRS_DATA = {
    "0->1": [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]], "1->0": [[0,0], [1,0], [1,-1], [0,2], [1,2]],
    "1->2": [[0,0], [1,0], [1,-1], [0,2], [1,2]], "2->1": [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
    "2->3": [[0,0], [1,0], [1,1], [0,-2], [1,-2]], "3->2": [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
    "3->0": [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]], "0->3": [[0,0], [1,0], [1,1], [0,-2], [1,-2]]
};

// BGMã®æº–å‚™
const bgm = new Audio();
bgm.loop = true; // çµ‚ã‚ã£ãŸã‚‰æœ€åˆã‹ã‚‰æµã™
bgm.volume = 0.4; // çˆ†éŸ³ã«ãªã‚‰ãªã„ã‚ˆã†ã«å°‘ã—ä¸‹ã’ã‚‹
let isBgmPlaying = false;

// æ›²ã®ãƒªã‚¹ãƒˆï¼ˆã‚ãªãŸã®æŒã£ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«åã«åˆã‚ã›ã¦ã­ï¼ï¼‰
const BGM_LIST = {
    standard: 'https://example.com/normal_bgm.mp3', // é€šå¸¸æ™‚
    fever: 'https://example.com/fast_bgm.mp3'       // ç››ã‚Šä¸ŠãŒã£ã¦ããŸæ™‚ç”¨
};

let arena = Array.from({length: 20}, () => new Array(10).fill(0));
let nextQueue = [], holdPiece = null, canHold = true, particles = [], lineFlashes = [], dropBeams = [], gridWaves = [];
let tSpinAnnounce = { text: '', life: 0, isBtB: false, isPerfect: false };
let fieldFlash = 0; 
let lockTimer = 0, moveCount = 0, btbActive = false, shakeTimer = 0, renCount = -1, isPaused = false;
// --- èƒŒæ™¯ã®ã‚­ãƒ©ã‚­ãƒ©è¨­å®š ---
let bgStars = [];
function createBackgroundStars() {
    bgStars = []; // åˆæœŸåŒ–
    for (let i = 0; i < 50; i++) {
        bgStars.push({
            x: Math.random() * 10, // æ¨ªå¹…(0~10)
            y: Math.random() * 20, // ç¸¦å¹…(0~20)
            size: Math.random() * 0.05 + 0.02,
            speed: Math.random() * 0.01 + 0.005,
            opacity: Math.random()
        });
    }
}
createBackgroundStars();

const LOCK_DELAY = 1000, MAX_MOVES = 15;
const player = { pos: {x: 3, y: 0}, matrix: null, type: null, rotation: 0, score: 0, lastOpWasRotate: false };

let stats = {
    highScore: 0, maxRen: 0, totalLines: 0, tetris: 0, ts: 0, td: 0, tt: 0, btb: 0
};

function updateStatsUI() {
    statElems.highScore.innerText = stats.highScore;
    statElems.maxRen.innerText = stats.maxRen;
    statElems.totalLines.innerText = stats.totalLines;
    statElems.tetris.innerText = stats.tetris;
    statElems.ts.innerText = stats.ts;
    statElems.td.innerText = stats.td;
    statElems.tt.innerText = stats.tt;
    statElems.btb.innerText = stats.btb;
}

const DAS_DELAY = 160, ARR_SPEED = 30;
let keys = {};
let dasTimers = { 37: 0, 39: 0, 40: 0 };
let lastRepeat = { 37: 0, 39: 0, 40: 0 };

let prevGamepadState = { buttons: [], axes: [] };

window.addEventListener('keydown', e => {
    if (isPaused && e.keyCode !== 27) return; 
    if (keys[e.keyCode]) return;
    keys[e.keyCode] = true;
    if (e.keyCode === 87 || e.keyCode === 32 || e.keyCode === 38) hardDrop();
    if (e.keyCode === 69) playerRotate(1);
    if (e.keyCode === 81) playerRotate(-1);
    if (e.keyCode === 67 || e.keyCode === 16) playerHold();
    if (e.keyCode === 27) toggleOptions();
});
window.addEventListener('keyup', e => { 
    keys[e.keyCode] = false; 
    if (dasTimers[e.keyCode] !== undefined) {
        dasTimers[e.keyCode] = 0;
        lastRepeat[e.keyCode] = 0;
    }
});
canvas.addEventListener('mousedown', e => { e.preventDefault(); if (isPaused) return; if (e.button === 0) playerRotate(-1); if (e.button === 2) playerRotate(1); });
window.addEventListener('wheel', e => { e.preventDefault(); if (!isPaused) playerHold(); }, { passive: false });

function createPiece(type) {
    if (type === 'I') return [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]];
    if (type === 'L') return [[0,0,2],[2,2,2],[0,0,0]];
    if (type === 'J') return [[3,0,0],[3,3,3],[0,0,0]];
    if (type === 'O') return [[4,4],[4,4]];
    if (type === 'Z') return [[5,5,0],[0,5,5],[0,0,0]];
    if (type === 'S') return [[0,6,6],[6,6,0],[0,0,0]];
    if (type === 'T') return [[0,7,0],[7,7,7],[0,0,0]];
}
function rotateMatrix(matrix, dir) {
    for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) { [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; }
    }
    if (dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse();
}
function resetLock() { if (moveCount < MAX_MOVES) { lockTimer = 0; moveCount++; } }
function playerRotate(dir) {
    const startRot = player.rotation;
    const nextRot = (startRot + (dir > 0 ? 1 : 3)) % 4;
    const pos = {x: player.pos.x, y: player.pos.y};
    rotateMatrix(player.matrix, dir);
    
    const kicks = SRS_DATA[`${startRot}->${nextRot}`] || [[0,0]];
    for (const kick of kicks) {
        player.pos.x = pos.x + kick[0]; player.pos.y = pos.y - kick[1];
        if (!collide(arena, player)) { 
            player.rotation = nextRot; 
            player.lastOpWasRotate = true; 
            resetLock(); 

            // --- âœ¨ ã“ã“ã‹ã‚‰è¿½åŠ ï¼šT-Spinã‚¹ãƒ­ãƒƒãƒˆã«ã¯ã¾ã£ãŸéŸ³ã®åˆ¤å®š ---
            if (player.type === 'T') {
                let corners = 0; 
                const cx = player.pos.x + 1; 
                const cy = player.pos.y + 1;
                [[cx-1, cy-1], [cx+1, cy-1], [cx-1, cy+1], [cx+1, cy+1]].forEach(([x, y]) => { 
                    if (x < 0 || x >= 10 || y >= 20 || (y >= 0 && arena[y][x] !== 0)) corners++; 
                });
                
                if (corners >= 3) {
                    SE.tSpinSet(); // ã€Œã‚¬ã‚­ãƒ³ï¼ã€ã¨é³´ã‚‰ã™
                    // æ¼”å‡ºï¼šã¡ã‚‡ã£ã¨ã ã‘ç”»é¢ã‚’å…‰ã‚‰ã›ã‚‹ã®ã‚‚ã‚¢ãƒªï¼
                    fieldFlash = 10; 
                } else {
                    SE.rotate(); // æ™®é€šã®å›è»¢éŸ³
                }
            } else {
                SE.rotate(); // TãƒŸãƒä»¥å¤–ã¯æ™®é€šã®å›è»¢éŸ³
            }
            // --- âœ¨ ã“ã“ã¾ã§ ---
            
            return; 
        }
        player.pos.x = pos.x; player.pos.y = pos.y;
    }
    rotateMatrix(player.matrix, -dir);
}function playerMove(dir) {
SE.move();
    player.pos.x += dir;
    if (collide(arena, player)) { player.pos.x -= dir; return false; }
    else { player.lastOpWasRotate = false; resetLock(); return true; }
}
function collide(arena, p) {
    const [m, o] = [p.matrix, p.pos];
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0) {
                let ay_check = y + o.y, ax_check = x + o.x;
                if (ax_check < 0 || ax_check >= 10 || ay_check >= 20 || (ay_check >= 0 && arena[ay_check][ax_check] !== 0)) return true;
            }
        }
    }
    return false;
}
function playerHold() {
    if (!canHold) return;
SE.hold();
    if (!holdPiece) { holdPiece = player.type; playerReset(); }
    else { const temp = player.type; player.type = holdPiece; holdPiece = temp; player.matrix = createPiece(player.type); player.pos.y = 0; player.pos.x = 3; player.rotation = 0; }
    canHold = false; drawSide();
}
function spawnSpark(x, y, count = 10, color = '255, 255, 255') {
    for(let i=0; i<count; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 0.8, // é£›ã³æ•£ã‚‹é€Ÿã•UP
            vy: (Math.random() - 0.5) * 0.8,
            life: 1.0,
            size: Math.random() * 0.25 + 0.05,
            color: color,
            gravity: 0.02 // ä¸‹ã«è½ã¡ã‚‹é‡åŠ›ï¼
        });
    }
}
function hexToRgb(hex) { if (!hex) return "255,255,255"; const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16); return `${r}, ${g}, ${b}`; }

function arenaSweep() {
    let lines = 0, isTSpin = false;
    
    // --- T-Spin åˆ¤å®š ---
    if (player.type === 'T' && player.lastOpWasRotate) {
        let corners = 0; const cx = player.pos.x + 1; const cy = player.pos.y + 1;
        [[cx-1, cy-1], [cx+1, cy-1], [cx-1, cy+1], [cx+1, cy+1]].forEach(([x, y]) => { 
            if (x < 0 || x >= 10 || y >= 20 || (y >= 0 && arena[y][x] !== 0)) corners++; 
        });
        if (corners >= 3) {
            isTSpin = true;
            //SE.tSpinSet(); // âœ¨ ã‚¬ãƒãƒ£ãƒƒï¼ˆT-Spinç¢ºå®šéŸ³ï¼‰
        }
    }

    // --- ãƒ©ã‚¤ãƒ³æ¶ˆå»å‡¦ç† ---
    for (let y = arena.length - 1; y >= 0; --y) {
        if (arena[y].every(v => v !== 0)) {
            lineFlashes.push({ y: y, life: 15 });
            gridWaves.push({ y: y, radius: 0, life: 40 });
            for(let x=0; x<10; x++) { 
                const rgb = hexToRgb(COLORS[arena[y][x]]); 
                spawnSpark(x + 0.5, y + 0.5, 12, rgb); 
            }
            arena.splice(y, 1); 
            arena.unshift(new Array(10).fill(0));
            lines++; y++;
        }
    }

    if (lines > 0) {
        renCount++; 
        stats.totalLines += lines;
        if (renCount > stats.maxRen) stats.maxRen = renCount;

        // --- RENï¼ˆã‚³ãƒ³ãƒœï¼‰ã®æ¼”å‡ºã¨éŸ³ ---
        renCountElement.innerText = renCount; 
        renContainer.style.transform = `scale(${1 + renCount * 0.15}) rotate(${Math.random() * 10 - 5}deg)`;
        renContainer.classList.add('bump'); 
        setTimeout(() => renContainer.classList.remove('bump'), 100); 
        const heat = Math.min(renCount * 25, 200); 
        renCountElement.style.color = `rgb(255, ${255 - heat}, 0)`; 
        
        SE.ren(renCount); // âœ¨ RENã®é«˜ã•ã«åˆã‚ã›ã¦éŸ³éšã‚¢ãƒƒãƒ—ï¼

        // --- ã‚¹ã‚³ã‚¢ãƒ»ç‰¹æ®Šåˆ¤å®šãƒ»éŸ³ã®åˆ†å² ---
        const isPowerMove = isTSpin || lines === 4;
        let b = [0, 100, 300, 500, 800][lines]; 
        if (renCount > 0) b += renCount * 50; 
        
        let isPerfectClear = arena.every(row => row.every(v => v === 0));

        if (isPowerMove) {
            let bonusText = ""; 
            if (btbActive) { b *= 1.5; bonusText = "ğŸ”¥ BtB "; stats.btb++; }
            
            if (isTSpin) { 
                const names = ["", "SINGLE", "DOUBLE", "TRIPLE"]; 
                tSpinAnnounce = { text: `${bonusText}T-SPIN ${names[lines]}!`, life: 100, isBtB: btbActive, isPerfect: false }; 
                b *= 2; 
                if(lines === 1) stats.ts++; else if(lines === 2) stats.td++; else if(lines === 3) stats.tt++;
                
                SE.tSpinClear(); // âœ¨ ãƒ‘ãƒ¯ãƒ•ãƒ«ãªT-Spinæ¶ˆå»éŸ³ï¼
fieldFlash = 40; // ç”»é¢ã‚’ä¸€ç¬ç™½ãå…‰ã‚‰ã›ã‚‹ï¼
    shakeTimer = 30; // æºã‚Œã‚’å¼·ã‚ã«ã™ã‚‹ï¼
    // ä½™è£•ãŒã‚ã‚Œã°ï¼šèƒŒæ™¯ã®ã‚­ãƒ©ã‚­ãƒ©ã‚’ä¸€ç¬ã ã‘é»„é‡‘è‰²ã«ã™ã‚‹
    bgStars.forEach(s => s.color = "255, 215, 0");
            } else if (lines === 4) { 
                tSpinAnnounce = { text: `${bonusText}TETRIS!`, life: 100, isBtB: btbActive, isPerfect: false }; 
                stats.tetris++;
                
                SE.tetris(); // âœ¨ çˆ½å¿«ãªãƒ†ãƒˆãƒªã‚¹éŸ³ï¼
            }
            btbActive = true; 
        } else { 
            btbActive = false; 
            SE.lineClear(); // âœ¨ é€šå¸¸ã®ãƒ©ã‚¤ãƒ³æ¶ˆå»éŸ³
        }

        // æºã‚Œã®è¨­å®š
        if (document.getElementById('shake-line').checked) {
            shakeTimer = (isPowerMove ? 20 : 10) + (renCount * 4);
        }

        // --- ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆã‚¯ãƒªã‚¢åˆ¤å®š ---
        if (isPerfectClear) {
            b += 3000;
            tSpinAnnounce = { text: "PERFECT CLEAR!!", life: 150, isBtB: false, isPerfect: true, bonus: "+3000" };
            shakeTimer = 50;
            fieldFlash = 60; 
            for(let i=0; i<100; i++) spawnSpark(Math.random()*10, Math.random()*20, 1, "255, 215, 0"); 
            
            SE.perfectClear(); // âœ¨ é‡ä½éŸ³ã®ã‹ã£ã“ã„ã„éŸ³ï¼
        }

        player.score += Math.floor(b); 
        if (player.score > stats.highScore) stats.highScore = player.score;
        scoreElement.innerText = player.score;
        updateStatsUI();
        
    } else {
        renCount = -1;
        renCountElement.innerText = "0"; 
        renContainer.style.transform = "scale(1) rotate(0deg)";
    }
}
function playerReset() {
    while (nextQueue.length < 14) nextQueue = nextQueue.concat([...PIECE_TYPES].sort(() => Math.random() - 0.5));
    player.type = nextQueue.shift(); player.matrix = createPiece(player.type);
    player.pos.y = 0; player.pos.x = 3; player.rotation = 0; player.lastOpWasRotate = false;
    lockTimer = 0; moveCount = 0; canHold = true;
    if (collide(arena, player)) resetGame();
    drawSide();
}
function lockPiece() { player.matrix.forEach((row, y) => { row.forEach((v, x) => { if (v !== 0) arena[y + player.pos.y][x + player.pos.x] = v; }); }); arenaSweep(); playerReset(); }
function playerDrop() { player.pos.y++; if (collide(arena, player)) { player.pos.y--; } else { player.lastOpWasRotate = false; lockTimer = 0; } dropCounter = 0; }
function hardDrop() { while(!collide(arena, {pos:{x:player.pos.x, y:player.pos.y+1}, matrix:player.matrix})) player.pos.y++; player.matrix.forEach((row, dy) => { row.forEach((v, dx) => { if (v !== 0) { const pieceColor = hexToRgb(COLORS[PIECE_TYPES.indexOf(player.type) + 1]); dropBeams.push({ x: player.pos.x + dx, y: player.pos.y + dy, life: 15, color: pieceColor }); spawnSpark(player.pos.x + dx + 0.5, player.pos.y + dy + 0.5, 5, "255, 255, 255"); } }); }); if (document.getElementById('shake-harddrop').checked) shakeTimer = 5; lockPiece();
SE.hardDrop(); }
function getGhostPos() { let ghost = { pos: {x: player.pos.x, y: player.pos.y}, matrix: player.matrix }; while (!collide(arena, { pos: {x: ghost.pos.x, y: ghost.pos.y + 1}, matrix: ghost.matrix })) { ghost.pos.y++; } return ghost.pos; }
function drawMatrix(m, o, ctx, isGhost = false) { m.forEach((r, y) => { r.forEach((v, x) => { if (v !== 0) { ctx.fillStyle = isGhost ? 'rgba(255,255,255,0.15)' : COLORS[v]; ctx.fillRect(x + o.x, y + o.y, 1, 1); ctx.lineWidth = 0.05; ctx.strokeStyle = isGhost ? 'rgba(0,210,255,0.3)' : "white"; ctx.strokeRect(x+o.x, y+o.y, 1, 1); } }); }); }
function drawSide() { holdCanvas.clearRect(0,0,60,60); if(holdPiece) drawMatrix(createPiece(holdPiece), {x:0.5, y:0.5}, holdCanvas); nextCtxs.forEach((ctx, i) => { ctx.clearRect(0,0,60,60); if(nextQueue[i]) drawMatrix(createPiece(nextQueue[i]), {x:0.5, y:0.5}, ctx); }); }

function draw() {
    if (shakeTimer > 0) { /* ...æºã‚Œã®å‡¦ç†... */ }
    context.clearRect(0, 0, canvas.width, canvas.height);

    // â˜…ã“ã“ã‹ã‚‰è¿½åŠ ï¼šèƒŒæ™¯ã®ã‚­ãƒ©ã‚­ãƒ©æç”»
    bgStars.forEach(star => {
        // ãµã‚ãµã‚ã¨ç‚¹æ»…ã•ã›ã‚‹è¨ˆç®—
        const twinkle = Math.abs(Math.sin(star.opacity)) * 0.5;
        context.fillStyle = `rgba(255, 255, 255, ${twinkle})`; 
        context.beginPath();
        // å°ã•ãªå††ï¼ˆæ˜Ÿï¼‰ã‚’æç”»
        context.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        context.fill();

        // æ˜Ÿã‚’ã‚†ã£ãã‚Šå‹•ã‹ã™
        star.y += star.speed;
        star.opacity += 0.02; 
        if (star.y > 20) star.y = 0; // ä¸‹ã¾ã§è¡Œã£ãŸã‚‰ä¸Šã«æˆ»ã‚‹
    });
    // â˜…ã“ã“ã¾ã§
    if (shakeTimer > 0) { const sx = (Math.random() - 0.5) * 0.5; const sy = (Math.random() - 0.5) * 0.5; canvas.style.transform = `translate(${sx}rem, ${sy}rem)`; shakeTimer--; } else { canvas.style.transform = `translate(0, 0)`; }
    context.clearRect(0, 0, canvas.width, canvas.height);

    if (fieldFlash > 0) {
        context.fillStyle = `rgba(0, 210, 255, ${fieldFlash / 80})`;
        context.fillRect(0, 0, 10, 20);
        fieldFlash--;
    }

    context.strokeStyle = 'rgba(0, 210, 255, 0.08)'; context.lineWidth = 0.02;
    for(let x=0; x<=10; x++) { context.beginPath(); context.moveTo(x, 0); context.lineTo(x, 20); context.stroke(); }
    for(let y=0; y<=20; y++) { context.beginPath(); context.moveTo(0, y); context.lineTo(10, y); context.stroke(); }
    gridWaves = gridWaves.filter(w => { const alpha = w.life / 30; context.strokeStyle = `rgba(0, 210, 255, ${alpha * 0.4})`; context.lineWidth = 0.1; for(let i=-2; i<=2; i++) { let r1 = w.y + i - Math.floor(w.radius), r2 = w.y + i + Math.floor(w.radius); if(r1 >= 0 && r1 < 20) { context.beginPath(); context.moveTo(0, r1); context.lineTo(10, r1); context.stroke(); } if(r2 >= 0 && r2 < 20) { context.beginPath(); context.moveTo(0, r2); context.lineTo(10, r2); context.stroke(); } } w.radius += 0.8; w.life--; return w.life > 0; });
    dropBeams = dropBeams.filter(b => { const alpha = b.life / 15; const grad = context.createLinearGradient(0, 0, 0, b.y + 1); grad.addColorStop(0, `rgba(${b.color}, 0)`); grad.addColorStop(1, `rgba(${b.color}, ${alpha * 0.5})`); context.fillStyle = grad; context.fillRect(b.x, 0, 1, b.y + 1); context.fillStyle = `rgba(255, 255, 255, ${alpha})`; context.fillRect(b.x + 0.4, 0, 0.2, b.y + 1); b.life--; return b.life > 0; });
    drawMatrix(arena, {x:0, y:0}, context); drawMatrix(player.matrix, getGhostPos(), context, true); drawMatrix(player.matrix, player.pos, context);
    lineFlashes = lineFlashes.filter(f => { context.fillStyle=`rgba(255,255,255,${f.life/10})`; context.fillRect(0, f.y, 10, 1); f.life--; return f.life > 0; });
   // drawé–¢æ•°ã®ä¸­ã«ã‚ã‚‹ particles = particles.filter(...) ã®éƒ¨åˆ†ã‚’ã“ã‚Œã«ï¼
particles = particles.filter(p => { 
    p.x += p.vx; 
    p.y += p.vy; 
    p.vy += p.gravity; // é‡åŠ›ã§ä¸‹ã«åŠ é€Ÿï¼
    p.life -= 0.02;    // æ¶ˆãˆã‚‹ã‚¹ãƒ”ãƒ¼ãƒ‰
    context.fillStyle = `rgba(${p.color}, ${p.life})`; 
    context.beginPath(); 
    context.arc(p.x, p.y, p.size, 0, Math.PI * 2); 
    context.fill(); 
    return p.life > 0; 
});
    
    if(tSpinAnnounce.life > 0) { 
        context.save(); 
        context.textAlign = "center"; 
        if (tSpinAnnounce.isPerfect) {
            context.fillStyle = `rgba(255, 215, 0, ${tSpinAnnounce.life/150})`; 
            context.font = "bold 1.8px 'Segoe UI'";
            context.fillText("PERFECT", 5, 8.5); 
            context.fillText("CLEAR!!", 5, 10.5);
            context.font = "bold 1.0px 'Segoe UI'";
            context.fillText(tSpinAnnounce.bonus, 5, 12.5);
        } else {
            context.fillStyle = tSpinAnnounce.isBtB ? `rgba(255, 215, 0, ${tSpinAnnounce.life/100})` : `rgba(0, 255, 204, ${tSpinAnnounce.life/100})`; 
            context.font = "bold 1.2px Arial";
            context.fillText(tSpinAnnounce.text, 5, 8); 
        }
        context.restore(); 
        tSpinAnnounce.life -= 1.5; 
    }
}

// --- ã€ä¿®æ­£ã€‘ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰å…¥åŠ›ã®ç›£è¦– (ãƒ¡ãƒ‹ãƒ¥ãƒ¼æ“ä½œå¯¾å¿œ) ---
function updateGamepad() {
    const gamepads = navigator.getGamepads();
    if (!gamepads[0]) return;
    const gp = gamepads[0];

    // ãƒœã‚¿ãƒ³ã®ã€ŒæŠ¼ã•ã‚ŒãŸç¬é–“ã€ã‚’åˆ¤å®šã™ã‚‹
    const isJustPressed = (idx) => {
        const b = gp.buttons[idx];
        if (!b) return false;
        const val = b.value !== undefined ? b.value : (b.pressed ? 1 : 0);
        const prevVal = prevGamepadState.buttons[idx] || 0;
        return val > 0.2 && prevVal <= 0.2;
    };

    // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãŒé–‹ã„ã¦ã„ã‚‹æ™‚ã®æ“ä½œ
    if (isPaused) {
        // åå­—ã‚­ãƒ¼ä¸Šä¸‹ ã¾ãŸã¯ ã‚¹ãƒ†ã‚£ãƒƒã‚¯ä¸Šä¸‹ ã§é¸æŠç§»å‹•
        const upPressed = isJustPressed(12) || (gp.axes[1] < -0.5 && (prevGamepadState.axes[1] || 0) >= -0.5);
        const downPressed = isJustPressed(13) || (gp.axes[1] > 0.5 && (prevGamepadState.axes[1] || 0) <= 0.5);

        if (upPressed) {
            currentMenuIndex = (currentMenuIndex - 1 + activeMenuElements.length) % activeMenuElements.length;
            updateMenuSelection();
        }
        if (downPressed) {
            currentMenuIndex = (currentMenuIndex + 1) % activeMenuElements.length;
            updateMenuSelection();
        }

        // Bãƒœã‚¿ãƒ³(1)ã§æ±ºå®š
        if (isJustPressed(0)) {
            activeMenuElements[currentMenuIndex].click();
        }
        // Aãƒœã‚¿ãƒ³(0)ã§é–‰ã˜ã‚‹
        if (isJustPressed(1)) {
            if (document.getElementById('shop-overlay').style.display === 'flex') toggleShop();
            else if (document.getElementById('options-overlay').style.display === 'flex') toggleOptions();
        }
        
    } else {
        // é€šå¸¸ãƒ—ãƒ¬ã‚¤ä¸­ã®æ“ä½œ
        const leftPressed = (gp.buttons[14] && gp.buttons[14].pressed) || gp.axes[0] < -0.5;
        const rightPressed = (gp.buttons[15] && gp.buttons[15].pressed) || gp.axes[0] > 0.5;
        const downPressed = (gp.buttons[13] && gp.buttons[13].pressed) || gp.axes[1] > 0.5;

        if (leftPressed) { if(!keys[37]) keys[37] = true; } else { if(keys[37]) { keys[37] = false; dasTimers[37] = 0; lastRepeat[37] = 0; } }
        if (rightPressed) { if(!keys[39]) keys[39] = true; } else { if(keys[39]) { keys[39] = false; dasTimers[39] = 0; lastRepeat[39] = 0; } }
        if (downPressed) { keys[40] = true; } else { keys[40] = false; }

        if (isJustPressed(1)) playerRotate(1);  // Bãƒœã‚¿ãƒ³ç›¸å½“
        if (isJustPressed(0)) playerRotate(-1); // Aãƒœã‚¿ãƒ³ç›¸å½“
        if (isJustPressed(12) || (gp.axes[1] < -0.5 && (prevGamepadState.axes[1] || 0) >= -0.5)) hardDrop();
        if (isJustPressed(4) || isJustPressed(5)) playerHold();

        // View(ã‚»ãƒ¬ã‚¯ãƒˆ)ãƒœã‚¿ãƒ³(8) ã¾ãŸã¯ Menu(ã‚¹ã‚¿ãƒ¼ãƒˆ)ãƒœã‚¿ãƒ³(9) ã§ãƒ¡ãƒ‹ãƒ¥ãƒ¼é–‹é–‰
        if (isJustPressed(8)) toggleShop();
        if (isJustPressed(9)) toggleOptions();
    }

    prevGamepadState.buttons = gp.buttons.map(b => b.value);
    prevGamepadState.axes = [...gp.axes];
}

// --- ãƒ¡ãƒ‹ãƒ¥ãƒ¼é¸æŠã®è¦–è¦šçš„æ›´æ–° ---
function updateMenuSelection() {
SE.menuSelect();
    activeMenuElements.forEach((el, idx) => {
        if (idx === currentMenuIndex) el.classList.add('selected');
        else el.classList.remove('selected');
    });
}

function handleInput(now) { 
    if (isPaused) return;
    updateGamepad(); 
    
    const moveSettings = [
        { key: 37, alt: 65, dir: -1 }, // å·¦ (Left, A)
        { key: 39, alt: 68, dir: 1 }   // å³ (Right, D)
    ];

    // ä¸¡æ–¹ã®ã‚­ãƒ¼ï¼ˆã¾ãŸã¯ä»£ç”¨ã‚­ãƒ¼ï¼‰ãŒæŠ¼ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    const leftDown = keys[37] || keys[65];
    const rightDown = keys[39] || keys[68];

    moveSettings.forEach(({key, alt, dir}) => { 
        const isThisDown = keys[key] || keys[alt];
        const isOtherDown = (dir === -1) ? rightDown : leftDown;

        if (isThisDown) {
            // ã€é‡è¦ã€‘ä¸¡æ–¹æŠ¼ã•ã‚Œã¦ã„ã‚‹å ´åˆã€å¾Œã‹ã‚‰æŠ¼ã—ãŸæ–¹ã‚’å„ªå…ˆã™ã‚‹ãŸã‚ã«
            // DASã‚¿ã‚¤ãƒãƒ¼ãŒæ–°ã—ã„ï¼ˆå¤§ãã„ï¼‰æ–¹ã‚’å„ªå…ˆã€ã¾ãŸã¯å˜ç´”ã«æ’ä»–åˆ¶å¾¡ã™ã‚‹
            if (isOtherDown) {
                // ä¸¡æŠ¼ã—æ™‚ã¯ã€å¾Œã‹ã‚‰æŠ¼ã•ã‚ŒãŸã‚­ãƒ¼ï¼ˆã‚¿ã‚¤ãƒãƒ¼ãŒæ–°ã—ã„æ–¹ï¼‰ã®ã¿å‡¦ç†
                const otherKey = (dir === -1) ? (keys[39] ? 39 : 68) : (keys[37] ? 37 : 65);
                if (dasTimers[key] < dasTimers[otherKey]) return; 
            }

            if (dasTimers[key] === 0) { 
                playerMove(dir); 
                dasTimers[key] = now; 
                lastRepeat[key] = now; 
            } 
            else if (now - dasTimers[key] > DAS_DELAY) { 
                if (now - lastRepeat[key] > ARR_SPEED) { 
                    playerMove(dir); 
                    lastRepeat[key] = now; 
                } 
            } 
        } else {
            // ã‚­ãƒ¼ãŒé›¢ã•ã‚ŒãŸã‚‰ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
            dasTimers[key] = 0;
            lastRepeat[key] = 0;
        }
    }); 
}

// --- ãƒ¡ãƒ‹ãƒ¥ãƒ¼é–‹é–‰ã®æ‹¡å¼µ ---
function toggleShop() { 
SE.menuOpen();
    const s = document.getElementById('shop-overlay'); 
    isPaused = (s.style.display !== 'flex'); 
    s.style.display = isPaused ? 'flex' : 'none'; 
    if (isPaused) {
        activeMenuElements = Array.from(document.querySelectorAll('#shop-card .menu-item, #shop-card .close-btn'));
        currentMenuIndex = 0;
        updateMenuSelection();
    }
}

function toggleOptions() { 
SE.menuOpen();
    const o = document.getElementById('options-overlay'); 
    isPaused = (o.style.display !== 'flex'); 
    o.style.display = isPaused ? 'flex' : 'none'; 
    if (isPaused) {
        activeMenuElements = Array.from(document.querySelectorAll('#options-card .menu-item, #options-card .close-btn'));
        currentMenuIndex = 0;
        updateMenuSelection();
    }
}

// ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã§æ“ä½œã™ã‚‹ãŸã‚ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼
function toggleCheckbox(id) {
    const cb = document.getElementById(id);
    cb.checked = !cb.checked;
}

function resetGame() { 
    arena.forEach(row => row.fill(0)); 
    player.score = 0; scoreElement.innerText = 0; 
    btbActive = false; renCount = -1; 
    renCountElement.innerText = "0"; renCountElement.style.color = "#ff9900"; 
    holdPiece = null; nextQueue = []; 
    stats.maxRen = 0; stats.totalLines = 0; stats.tetris = 0; stats.ts = 0; stats.td = 0; stats.tt = 0; stats.btb = 0;
    updateStatsUI();
    playerReset(); fieldFlash = 0; 
    if (document.getElementById('options-overlay').style.display === 'flex') toggleOptions(); 
}

function prepareTemplate() { 
    arena.forEach(row => row.fill(0)); 
    player.score = 0; scoreElement.innerText = 0; 
    btbActive = false; renCount = -1; 
    renCountElement.innerText = "0"; renCountElement.style.color = "#ff9900"; 
    holdPiece = null; nextQueue = []; 
}

function buyTSpinTemplate() {
    isMagicBuilding = true;
    
    // --- âœ¨ ã“ã“ã‹ã‚‰ï¼šãƒ‡ãƒ¼ã‚¿ã®ãƒªã‚»ãƒƒãƒˆå‡¦ç† ---
    player.score = 0;              // ã‚¹ã‚³ã‚¢ã‚’0ã«
    renCount = -1;                 // RENï¼ˆã‚³ãƒ³ãƒœï¼‰ã‚’ãƒªã‚»ãƒƒãƒˆ
    btbActive = false;             // Back to Backã‚’è§£é™¤
    
    // çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã‚‚ãƒªã‚»ãƒƒãƒˆã—ãŸã„å ´åˆã¯ã“ã“ã‚‚ï¼ˆãŠå¥½ã¿ã§ï¼ï¼‰
    stats.totalLines = 0;
    stats.tetris = 0;
    stats.ts = 0; stats.td = 0; stats.tt = 0;
    stats.btb = 0;

    // UIã®è¡¨ç¤ºã‚‚ãƒªã‚»ãƒƒãƒˆ
    scoreElement.innerText = "0";
    renCountElement.innerText = "0";
    renContainer.style.transform = "scale(1) rotate(0deg)";
    updateStatsUI();
    // --- âœ¨ ã“ã“ã¾ã§ ---

    arena = Array.from({length: 20}, () => new Array(10).fill(0));
    
    const pattern = [
        "1110111111", "1100111111", "1110111111", 
        "1000111111", "1001111111", "1001111111", "1011111111", 
        "1000111111", "1100111111", "1100111111", "1110111111", 
        "1000111111", "1001111111", "1001111111", "1011111111", 
        "1000000000", "1100000000", "0000000000", "0000000000", "0000000000"
    ].reverse();

    const blockPositions = [];
    for(let y = 0; y < 20; y++) {
        for(let x = 0; x < 10; x++) {
            if (pattern[y] && pattern[y][x] === "1") {
                blockPositions.push({x, y, color: 8});
            }
        }
    }

    blockPositions.forEach((block, i) => {
        setTimeout(() => {
            arena[block.y][block.x] = block.color;
            if (i % 2 === 0) SE.playTone(600 + (i * 2), 'sine', 0.05, 0.02);
            if (i % 5 === 0) {
                spawnSpark(block.x + 0.5, block.y + 0.5, 3, "150, 150, 150");
                shakeTimer = 1;
            }
            drawSide(); 
        }, i * 10); 
    });

    const totalTime = blockPositions.length * 10;
    setTimeout(() => {
        nextQueue = Array(20).fill('T').concat(nextQueue);
        playerReset();
        SE.menuOpen();
        isMagicBuilding = false; 
    }, totalTime + 100);

    toggleShop();
}

function buyRenTemplate() {
    isMagicBuilding = true;

    // ãƒ‡ãƒ¼ã‚¿ã®ãƒªã‚»ãƒƒãƒˆ
    player.score = 0;
    renCount = -1;
    btbActive = false;
    stats.totalLines = 0;
    updateStatsUI();
    scoreElement.innerText = "0";
    renCountElement.innerText = "0";

// --- âœ¨ ãƒã‚¯ã‚¹ãƒˆã‚’1å·¡ç›®ã‹ã‚‰ãƒªã‚»ãƒƒãƒˆ ---
    nextQueue = []; // ä»Šã®ã‚­ãƒ¥ãƒ¼ã‚’ç©ºã£ã½ã«ã™ã‚‹
    // æœ€åˆã®7ç¨®ã‚»ãƒƒãƒˆã‚’ç”Ÿæˆ
    let firstBag = [...PIECE_TYPES].sort(() => Math.random() - 0.5);
    nextQueue = nextQueue.concat(firstBag); 
    // ã•ã‚‰ã«äºˆå‚™ã®ã‚»ãƒƒãƒˆã‚‚è¶³ã—ã¦ãŠãï¼ˆåˆè¨ˆ14å€‹ï¼‰
    let secondBag = [...PIECE_TYPES].sort(() => Math.random() - 0.5);
    nextQueue = nextQueue.concat(secondBag);
    // --- âœ¨ ã“ã“ã¾ã§ ---

    arena = Array.from({length: 20}, () => new Array(10).fill(0));
    
    const blockPositions = [];
    // åº§æ¨™ã®è¨ˆç®—
    for(let y = 0; y < 20; y++) {
        for(let x = 0; x < 10; x++) {
            let isBlock = false;
            
            if (y === 19) {
                // åº•ã®éƒ¨åˆ†ï¼ˆã‚³ãƒ³ãƒœã®ç¨®ï¼‰
                if (x !== 6) isBlock = true; 
            } else if (y >= 2) { // âœ¨ ã“ã“ï¼y=2ï¼ˆä¸Šã‹ã‚‰3æ®µç›®ï¼‰ã‹ã‚‰ä¸‹ã‚’å…¨éƒ¨åŸ‹ã‚ã‚‹ï¼
                // çœŸã‚“ä¸­4åˆ—(3,4,5,6)ä»¥å¤–ã‚’ã™ã¹ã¦ãƒ–ãƒ­ãƒƒã‚¯ã«ã™ã‚‹
                if (x < 3 || x > 6) isBlock = true;
            }
            
            if (isBlock) {
                blockPositions.push({x, y, color: 8});
            }
        }
    }

    // ä¸‹ã‹ã‚‰é †ã«ã€Œã‚·ãƒ¥ãƒãƒãƒãƒƒï¼ã€
    blockPositions.reverse().forEach((block, i) => {
        setTimeout(() => {
            arena[block.y][block.x] = block.color;
            if (i % 4 === 0) SE.playTone(300 + (i * 3), 'sine', 0.05, 0.02);
            if (i % 10 === 0) {
                spawnSpark(block.x + 0.5, block.y + 0.5, 2, "100, 200, 255");
                shakeTimer = 1;
            }
            drawSide(); 
        }, i * 5); // ãƒ–ãƒ­ãƒƒã‚¯ãŒå¤šã„ã®ã§ã€ã•ã‚‰ã«ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—(5ms)ï¼
    });

    const totalTime = blockPositions.length * 5;
    setTimeout(() => {
        playerReset();
        SE.menuOpen();
        isMagicBuilding = false;
    }, totalTime + 100);

    toggleShop();
}


function buyHachimitsu() { prepareTemplate(); const pattern = ["1111000000", "1111001100", "1110001111", "1110111111", "1110011111", "1110111111", "1111011111"].reverse(); for(let y = 0; y < pattern.length; y++) { for(let x = 0; x < 10; x++) if (pattern[y][x] === "1") arena[19 - y][x] = 8; } nextQueue = ['T', 'T', 'I', 'S', 'Z', 'O', 'L', 'J'].concat(nextQueue); playerReset(); toggleShop(); }
function buyOpeningTD() { prepareTemplate(); const pattern = ["0001110000", "1001111000", "1000111111", "1101111111"]; for(let i = 0; i < pattern.length; i++) { const yCoord = 19 - (pattern.length - 1 - i); for(let x = 0; x < 10; x++) if (pattern[i][x] === "1") arena[yCoord][x] = 8; } const openingSequence = ['T', ...(['S', 'Z', 'J'].sort(() => Math.random() - 0.5)), ...(['O', 'L', 'I'].sort(() => Math.random() - 0.5))]; nextQueue = openingSequence.concat([...PIECE_TYPES].sort(() => Math.random() - 0.5)); playerReset(); toggleShop(); }

// --- SE (éŸ³éŸ¿) ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

const SE = {
    enabled: true,
    
    // åŸºæœ¬ã®éŸ³ã‚’ä½œã‚‹é–¢æ•°
    playTone(freq, type, duration, volume = 0.1, ramp = true) {
        if (!this.enabled) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        
        osc.type = type; // square, triangle, sine, sawtooth
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        
        gain.gain.setValueAtTime(volume, audioCtx.currentTime);
        if (ramp) {
            gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
        }
        
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    },

    move() { this.playTone(200, 'sine', 0.05, 0.05); }, // æ§ãˆã‚ãªéŸ³
    rotate() { this.playTone(400, 'triangle', 0.1, 0.1); }, // ã‚«ãƒãƒƒ
    hold() { this.playTone(600, 'sine', 0.1, 0.1); }, // ãƒãƒ³ãƒƒ
    hardDrop() { this.playTone(150, 'square', 0.2, 0.1); }, // ã‚«ãƒ³ãƒƒï¼
    
    menuSelect() { this.playTone(800, 'sine', 0.05, 0.05); }, // ã½ã£
    menuOpen() { this.playTone(300, 'square', 0.1, 0.05); this.playTone(500, 'square', 0.15, 0.05); }, // ã‚¬ãƒãƒ£

    lineClear() { this.playTone(1000, 'sine', 0.3, 0.1); }, // çˆ½å¿«
    tetris() { // ãƒ†ãƒˆãƒªã‚¹ï¼ˆ4åˆ—ï¼‰
        [440, 554, 659, 880].forEach((f, i) => {
            setTimeout(() => this.playTone(f, 'sine', 0.4, 0.1), i * 50);
        });
    },

    tSpinSet() { this.playTone(200, 'sawtooth', 0.2, 0.1); }, // ã‚¬ãƒãƒ£ãƒƒï¼ˆã¯ã‚ãŸæ™‚ï¼‰
   tSpinClear() { // âœ¨ ãƒ‘ãƒ¯ãƒ•ãƒ«ãªé‡ä½éŸ³T-SPIN
        const now = audioCtx.currentTime;
        
        // 1. ä½éŸ³ã®æŸ±ï¼ˆãƒ‰ã‚©ã‚©ã‚©ãƒ³ã¨ã„ã†é‡ã¿ï¼‰
        this.playTone(60, 'sawtooth', 0.6, 0.2); 
        this.playTone(120, 'sawtooth', 0.5, 0.15);
        
        // 2. ãƒ†ãƒˆãƒªã‚¹é¢¨ã®é«˜éŸ³æˆåˆ†ã‚’å°‘ã—æ··ãœã‚‹ï¼ˆã‚­ãƒ¬ã‚’å‡ºã™ï¼‰
        setTimeout(() => this.playTone(440, 'sine', 0.4, 0.1), 50);
        setTimeout(() => this.playTone(880, 'sine', 0.3, 0.05), 100);

        // 3. æŒ¯å‹•æ„Ÿï¼ˆå°‘ã—ãƒ”ãƒƒãƒã‚’æºã‚‰ã™ã¨ã‚ˆã‚Šå¼·åŠ›ã«èã“ãˆã¾ã™ï¼‰
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(80, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.5); // éŸ³ãŒä½ãæ²ˆã¿è¾¼ã‚€
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.6);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(now + 0.6);
    },

    ren(count) {
        const pitch = 440 + (count * 40); // RENã‚’é‡ã­ã‚‹ã»ã©é«˜ã
        this.playTone(pitch, 'sine', 0.2, 0.1);
    },

    perfectClear() {
        const now = audioCtx.currentTime;
        [55, 110, 220].forEach(f => this.playTone(f, 'square', 1.0, 0.2, false)); // é‡ä½éŸ³
    },
tSpinSet() { 
        // ã€Œã‚¬ã‚­ãƒ³ï¼ã€ã¨ã„ã†ã€ä½•ã‹ãŒãƒ­ãƒƒã‚¯ã•ã‚ŒãŸã‚ˆã†ãªé‹­ã„éŸ³
        this.playTone(300, 'square', 0.15, 0.1); 
        setTimeout(() => this.playTone(150, 'square', 0.2, 0.15), 50);
    }
};


function toggleSE() {
    const cb = document.getElementById('se-toggle');
    cb.checked = !cb.checked; // ã‚¯ãƒªãƒƒã‚¯ã§åè»¢
    SE.enabled = cb.checked;
    if (SE.enabled) {
        audioCtx.resume(); // ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆ¶é™è§£é™¤ç”¨
        SE.menuSelect();
    }
}

function loadLocalBGM(input) {
    if (input.files && input.files[0]) {
        const file = input.files[0];
        const url = URL.createObjectURL(file); // ãƒ‘ã‚½ã‚³ãƒ³å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¸€æ™‚çš„ãªä½æ‰€ï¼ˆURLï¼‰ã‚’ä½œã‚‹é­”æ³•
        
        bgm.src = url;
        bgm.load();
        
        // èª­ã¿è¾¼ã‚“ã ã‚‰ã™ãå†ç”Ÿï¼
        bgm.play().then(() => {
            isBgmPlaying = true;
        }).catch(e => console.log("å†ç”Ÿã«ã¯ã‚¯ãƒªãƒƒã‚¯ãŒå¿…è¦ã§ã™"));
        
        toggleOptions(); // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹
    }
}

function startBGM(type = 'standard') {
    bgm.src = BGM_LIST[type];
    bgm.play().then(() => {
        isBgmPlaying = true;
    }).catch(err => {
        console.log("ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆ¶é™ã§ã€ç”»é¢ã‚’ä¸€åº¦ã‚¯ãƒªãƒƒã‚¯ã—ãªã„ã¨éŸ³ãŒå‡ºãªã„ã‚ˆï¼");
    });
}

function stopBGM() {
    bgm.pause();
    isBgmPlaying = false;
}

// --- ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆé…ç½®æ¼”å‡º (é­”æ³•ã®ç©ã¿ä¸Šã’) ---
function applyTemplateWithMagic(matrix) {
    // 1. ä»Šã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã‚¯ãƒªã‚¢
    arena = Array.from({length: 20}, () => new Array(10).fill(0));
    
    let delay = 0;
    const blockPositions = [];

    // ç©ã¿ä¸Šã’ã‚‹ã¹ããƒ–ãƒ­ãƒƒã‚¯ã®ä½ç½®ã‚’ãƒªã‚¹ãƒˆã‚¢ãƒƒãƒ—
    for (let y = 0; y < matrix.length; y++) {
        for (let x = 0; x < matrix[y].length; x++) {
            if (matrix[y][x] !== 0) {
                blockPositions.push({x, y, color: matrix[y][x]});
            }
        }
    }

    // 2. ä¸‹ã‹ã‚‰é †ã«ã€æ™‚é–“å·®ã§é…ç½®ã—ã¦ã„ã
    blockPositions.reverse().forEach((block, i) => {
        setTimeout(() => {
            arena[block.y][block.x] = block.color;
            
            // é…ç½®ã®ç¬é–“ã«ç«èŠ±ã¨éŸ³ï¼
            const rgb = hexToRgb(COLORS[block.color]);
            spawnSpark(block.x + 0.5, block.y + 0.5, 5, rgb);
            
            // ã‚·ãƒ¥ãƒãƒƒã¨ã„ã†éŸ³ (é«˜ã‚ã®éŸ³ã‚’çŸ­ã)
            SE.playTone(800 + (i * 10), 'sine', 0.05, 0.03);
            
            // ç”»é¢ã‚’å°‘ã—æºã‚‰ã™
            shakeTimer = 1;
            
            drawSide(); // ç”»é¢æ›´æ–°
        }, i * 20); // 20msé–“éš”ã§ã€Œã‚·ãƒ¥ãƒãƒãƒãƒƒï¼ã€
    });

    // æœ€å¾Œã«å®Œäº†éŸ³ï¼
   setTimeout(() => {
        playerReset();
        SE.menuOpen();
        isMagicBuilding = false;
        
        // âœ¨ ã“ã“ã§BGMã‚¹ã‚¿ãƒ¼ãƒˆï¼
        startBGM('standard');
    }, totalTime + 100);
}

let dropCounter = 0, lastTime = 0;
function update(time = 0) {
    const dt = time - lastTime; lastTime = time; 
    if (!isPaused) {
        dropCounter += dt; handleInput(time);
        if (collide(arena, {pos:{x:player.pos.x, y:player.pos.y+1}, matrix:player.matrix})) { lockTimer += dt; if(lockTimer >= LOCK_DELAY) lockPiece(); } 
        else { let threshold = (keys[40] || keys[83]) ? 50 : 1000; if (dropCounter > threshold) playerDrop(); }
    } else {
        updateGamepad();
    }
    draw(); requestAnimationFrame(update);
}
playerReset(); 
updateStatsUI();
update();
</script>
</body>
</html>
